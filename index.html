<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="mobile-web-app-capable" content="yes" />
    <title>For Honey!</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&display=swap" rel="stylesheet">

    <style>
        *, *::before, *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            height: 100%;
            width: 100%;
            overscroll-behavior: none;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
            font-family: "Inter", sans-serif;
            overflow: hidden;
            background: #020204;
            background-image:
                radial-gradient(circle at 50% 35%, #141f2d 0%, transparent 65%),
                linear-gradient(180deg, #000000 0%, #00040a 100%);
            color: #eee;
            /* Prevents automatic text inflation on mobile browsers */
            -webkit-text-size-adjust: 100%;
            text-size-adjust: 100%;

            /* --- FIX: Disable text selection when dragging --- */
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none;    /* Firefox */
            -ms-user-select: none;     /* IE 10+ */
            user-select: none;         /* Standard syntax */
        }
        #container {
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100vh;
        }
        .vignette {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 9;
            background: radial-gradient(circle at center, rgba(0,0,0,0) 65%, rgba(0,0,0,.5) 100%);
        }
        canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
            touch-action: none;
        }
        .instructions {
            position: fixed;
            left: 24px;
            bottom: 24px;
            padding: 10px 20px;
            font-size: clamp(10px, 3vw, 12px);
            text-align: left;
            pointer-events: none;
            color: #b0d0ff;
            background: rgba(15, 18, 40, 0.25);
            border: 1px solid rgba(70, 122, 255, 0.28);
            border-radius: 12px;
            backdrop-filter: blur(12px);
            z-index: 10;
            box-shadow: 0 4px 20px rgba(0,0,0,.45);
        }
        #morphButton {
            position: fixed;
            left: 50%;
            bottom: 24px;
            transform: translateX(-50%);
            padding: 12px 30px;
            font-size: clamp(12px, 3.5vw, 14px);
            font-weight: 500;
            color: rgba(220, 230, 255, 0.9);
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50px;
            backdrop-filter: blur(10px) saturate(180%);
            -webkit-backdrop-filter: blur(10px) saturate(180%);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            cursor: pointer;
            z-index: 10;
            transition: all 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
            touch-action: manipulation;
        }
        #morphButton:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateX(-50%) scale(1.05);
            box-shadow: 0 12px 40px 0 rgba(0, 0, 0, 0.45);
            color: white;
        }
        #morphButton:active {
            transform: translateX(-50%) scale(0.98);
        }
        #loadingScreen {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #020204;
            z-index: 100;
            transition: opacity 0.5s ease-out;
            color: #b0d0ff;
            font-size: clamp(14px, 4vw, 16px);
            font-weight: 500;
            text-align: center;
        }
        #loadingScreen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #b0d0ff;
            border-top: 4px solid transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* --- Improved Mobile Styles --- */
        @media (max-width: 600px) {
            .instructions {
                /* Center instructions and move them above the button for a cleaner mobile layout */
                left: 50%;
                transform: translateX(-50%);
                bottom: 100px;
                padding: 8px 16px;
                text-align: center;
                width: max-content;
            }
            #morphButton {
                /* Give button more space from the bottom and a larger tap area */
                bottom: 30px;
                padding: 12px 30px;
                font-size: clamp(14px, 4vw, 15px);
            }
        }

        @media (pointer: coarse) {
            #morphButton {
                transform: translateX(-50%) scale(1.1);
            }
            #morphButton:active {
                transform: translateX(-50%) scale(1.05);
            }
        }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <div class="spinner"></div>
        <span>Loading Universe...</span>
    </div>
    <div id="container"></div>
    <div class="vignette"></div>
    <div class="instructions">Drag or swipe to explore<br>designed by Saswat</div>
    <button id="morphButton">CLICK HERE!</button>

    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/"
      }
    }
    </script>

    <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
    import { AfterimagePass } from "three/addons/postprocessing/AfterimagePass.js";
    import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
    import { FontLoader } from "three/addons/loaders/FontLoader.js";
    import { TextGeometry } from "three/addons/geometries/TextGeometry.js";
    import { MeshSurfaceSampler } from "three/addons/math/MeshSurfaceSampler.js";

    const PARTICLE_COUNT = 5000;
    const SPARK_COUNT = 600;
    const STAR_COUNT = 3000;

    let scene, camera, renderer, composer, controls;
    let particles, sparkles, stars;
    let clock = new THREE.Clock();
    let currentPattern = 0, isTrans = false, prog = 0;
    const morphSpeed = 0.03;
    let font;
    let isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

    function normalise(points, size) {
        if (points.length === 0) return [];
        const box = new THREE.Box3().setFromPoints(points);
        const maxDim = Math.max(...box.getSize(new THREE.Vector3()).toArray()) || 1;
        const centre = box.getCenter(new THREE.Vector3());
        return points.map(p => p.clone().sub(centre).multiplyScalar(size / maxDim));
    }

    function createTextShape(text, n, particleSize) {
        if (!font) return [];

        const geometry = new TextGeometry(text, {
            font: font,
            size: 30,
            depth: 2,
            curveSegments: 8,
            bevelEnabled: true,
            bevelThickness: 1,
            bevelSize: 0.5,
            bevelSegments: 4
        });
        geometry.center();

        const sampler = new MeshSurfaceSampler(new THREE.Mesh(geometry)).build();
        const pts = [];
        const tempPosition = new THREE.Vector3();

        for (let i = 0; i < n; i++) {
            sampler.sample(tempPosition);
            pts.push(tempPosition.clone());
        }

        geometry.dispose();
        return normalise(pts, particleSize);
    }

    function glaizaShape(n, time = 0) {
        return createTextShape("GLY", n, 80);
    }

    function isCoolShape(n, time = 0) {
        return createTextShape("am sorry", n, 80);
    }

    function starShape(n, time = 0) {
        const pts = [];
        const depth = 8;
        const numPoints = 5;
        const innerN = Math.floor(n * 0.4);
        const outerN = n - innerN;
        const twist = Math.sin(time * 0.3) * 0.1;

        const generateStarOutline = (count, outerR, innerR, d, jitter, layerTwist) => {
            const layerPts = [];
            const vertices = [];
            for (let i = 0; i < numPoints * 2; i++) {
                const radius = i % 2 === 0 ? outerR : innerR;
                let angle = (i / (numPoints * 2)) * Math.PI * 2;
                angle += layerTwist;
                vertices.push(new THREE.Vector3(Math.cos(angle) * radius, Math.sin(angle) * radius, 0));
            }

            for (let i = 0; i < count; i++) {
                const edgeIndex = Math.floor(Math.random() * numPoints * 2);
                const v1 = vertices[edgeIndex];
                const v2 = vertices[(edgeIndex + 1) % (numPoints * 2)];
                const pointOnEdge = new THREE.Vector3().lerpVectors(v1, v2, Math.random());

                pointOnEdge.x += (Math.random() - 0.5) * jitter;
                pointOnEdge.y += (Math.random() - 0.5) * jitter;
                pointOnEdge.z = (Math.random() - 0.5) * d;
                layerPts.push(pointOnEdge);
            }
            return layerPts;
        }

        const innerPts = generateStarOutline(innerN, 12, 6, depth * 0.8, 2, twist);
        const outerPts = generateStarOutline(outerN, 25, 12, depth, 3, -twist * 0.5);

        pts.push(...innerPts, ...outerPts);
        return normalise(pts, 55);
    }

    function heartShape(n, time = 0) {
        const pts = [];
        const depth = 12;
        const innerN = Math.floor(n * 0.5);
        const outerN = n - innerN;
        const beat = 1.0 + Math.pow(Math.sin(time * 1.5) * 0.5 + 0.5, 4.0) * 0.1;

        const generateHeartOutline = (count, scale, jitter) => {
            const layerPts = [];
            const path = [];
            const pathSteps = 200;
            for (let i = 0; i < pathSteps; i++) {
                const t = (i / pathSteps) * 2 * Math.PI;
                const x = scale * 16 * Math.pow(Math.sin(t), 3);
                const y = scale * (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
                path.push(new THREE.Vector3(x, y, 0));
            }

            for (let i = 0; i < count; i++) {
                const pt = path[Math.floor(Math.random() * path.length)].clone();
                pt.x += (Math.random() - 0.5) * jitter;
                pt.y += (Math.random() - 0.5) * jitter;
                pt.z = (Math.random() - 0.5) * depth;
                layerPts.push(pt);
            }
            return layerPts;
        }

        const innerPts = generateHeartOutline(innerN, 1.1 * beat, 2);
        const outerPts = generateHeartOutline(outerN, 2.2 * beat, 3);

        pts.push(...innerPts, ...outerPts);
        return normalise(pts, 50);
    }

    function torusKnotShape(n, time = 0) {
        const pts = [];
        const p = 2, q = 3;
        const innerN = Math.floor(n * 0.4);
        const outerN = n - innerN;
        const revolve = time * 0.1;

        const generateKnotOutline = (count, radius, tubeRadius, jitter) => {
            const layerPts = [];
            const path = [];
            const pathSteps = 400;

            for (let i = 0; i < pathSteps; i++) {
                const t = (i / pathSteps) * 2 * Math.PI + revolve;
                const r = Math.cos(q * t) + radius;
                const x = r * Math.cos(p * t);
                const y = r * Math.sin(p * t);
                const z = -Math.sin(q * t);
                path.push(new THREE.Vector3(x, y, z).multiplyScalar(10));
            }

            for (let i = 0; i < count; i++) {
                const pt = path[Math.floor(Math.random() * path.length)].clone();
                pt.x += (Math.random() - 0.5) * jitter;
                pt.y += (Math.random() - 0.5) * jitter;
                pt.z += (Math.random() - 0.5) * jitter;
                layerPts.push(pt);
            }
            return layerPts;
        }

        const innerPts = generateKnotOutline(innerN, 2, 0.4, 2);
        const outerPts = generateKnotOutline(outerN, 3, 0.6, 3);

        pts.push(...innerPts, ...outerPts);
        return normalise(pts, 60);
    }

    const PATTERNS = [glaizaShape, isCoolShape, starShape, heartShape, torusKnotShape];
    let basePositions = [];

    function createStars() {
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(STAR_COUNT * 3);
        const col = new Float32Array(STAR_COUNT * 3);
        const size = new Float32Array(STAR_COUNT);
        const rnd = new Float32Array(STAR_COUNT);
        const R = 900;
        for (let i = 0; i < STAR_COUNT; i++) {
            const i3 = i * 3, θ = Math.random() * 2 * Math.PI, φ = Math.acos(2 * Math.random() - 1), r = R * Math.cbrt(Math.random());
            pos[i3] = r * Math.sin(φ) * Math.cos(θ);
            pos[i3 + 1] = r * Math.sin(φ) * Math.sin(θ);
            pos[i3 + 2] = r * Math.cos(φ);
            const c = new THREE.Color().setHSL(Math.random() * 0.6, 0.3 + 0.3 * Math.random(), 0.55 + 0.35 * Math.random());
            col[i3] = c.r; col[i3 + 1] = c.g; col[i3 + 2] = c.b;
            size[i] = 0.25 + Math.pow(Math.random(), 4) * 2.1;
            rnd[i] = Math.random() * Math.PI * 2;
        }
        geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
        geo.setAttribute("color", new THREE.BufferAttribute(col, 3));
        geo.setAttribute("size", new THREE.BufferAttribute(size, 1));
        geo.setAttribute("random", new THREE.BufferAttribute(rnd, 1));
        const mat = new THREE.ShaderMaterial({
            uniforms: { time: { value: 0 } },
            vertexShader: `
                attribute float size;
                attribute float random;
                varying vec3 vColor;
                varying float vRnd;
                void main() {
                    vColor = color;
                    vRnd = random;
                    vec4 mv = modelViewMatrix * vec4(position, 1.);
                    gl_PointSize = size * (250. / -mv.z);
                    gl_Position = projectionMatrix * mv;
                }`,
            fragmentShader: `
                uniform float time;
                varying vec3 vColor;
                varying float vRnd;
                void main() {
                    vec2 uv = gl_PointCoord - 0.5;
                    float d = length(uv);
                    float a = 1.0 - smoothstep(0.4, 0.5, d);
                    a *= 0.7 + 0.3 * sin(time * (0.6 + vRnd * 0.3) + vRnd * 5.0);
                    if (a < 0.02) discard;
                    gl_FragColor = vec4(vColor, a);
                }`,
            transparent: true,
            depthWrite: false,
            vertexColors: true,
            blending: THREE.AdditiveBlending
        });
        return new THREE.Points(geo, mat);
    }

    function makeParticles(count, palette) {
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(count * 3);
        const col = new Float32Array(count * 3);
        const size = new Float32Array(count);
        const rnd = new Float32Array(count * 3);
        for (let i = 0; i < count; i++) {
            const i3 = i * 3, base = palette[Math.random() * palette.length | 0], hsl = { h: 0, s: 0, l: 0 };
            base.getHSL(hsl);
            hsl.h += (Math.random() - 0.5) * 0.05;
            hsl.s = Math.min(1, Math.max(0.7, hsl.s + (Math.random() - 0.5) * 0.3));
            hsl.l = Math.min(0.9, Math.max(0.5, hsl.l + (Math.random() - 0.5) * 0.4));
            const c = new THREE.Color().setHSL(hsl.h, hsl.s, hsl.l);
            col[i3] = c.r; col[i3 + 1] = c.g; col[i3 + 2] = c.b;
            size[i] = 1.0 + Math.random() * 1.5;
            rnd[i3] = Math.random() * 10;
            rnd[i3 + 1] = Math.random() * Math.PI * 2;
            rnd[i3 + 2] = 0.5 + 0.5 * Math.random();
        }
        geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
        geo.setAttribute("color", new THREE.BufferAttribute(col, 3));
        geo.setAttribute("size", new THREE.BufferAttribute(size, 1));
        geo.setAttribute("random", new THREE.BufferAttribute(rnd, 3));
        geo.setAttribute("basePosition", new THREE.BufferAttribute(pos.slice(), 3));

        const mat = new THREE.ShaderMaterial({
            uniforms: { time: { value: 0 }, hueSpeed: { value: 0.12 } },
            vertexShader: `
                uniform float time;
                attribute float size;
                attribute vec3 random;
                varying vec3 vCol;
                varying float vR;
                void main() {
                    vCol = color;
                    vR = random.z;
                    vec3 p = position;
                    float t = time * 0.25 * random.z;
                    float ax = t + random.y, ay = t * 0.75 + random.x;
                    float amp = (0.6 + sin(random.x + t * 0.6) * 0.3) * random.z;
                    p.x += sin(ax + p.y * 0.06 + random.x * 0.1) * amp;
                    p.y += cos(ay + p.z * 0.06 + random.y * 0.1) * amp;
                    p.z += sin(ax * 0.85 + p.x * 0.06 + random.z * 0.1) * amp;
                    vec4 mv = modelViewMatrix * vec4(p, 1.);
                    float pulse = 0.9 + 0.1 * sin(time * 1.15 + random.y);
                    gl_PointSize = size * pulse * (350. / -mv.z);
                    gl_Position = projectionMatrix * mv;
                }`,
            fragmentShader: `
                uniform float time;
                uniform float hueSpeed;
                varying vec3 vCol;
                varying float vR;
                vec3 hueShift(vec3 c, float h) {
                    const vec3 k = vec3(0.57735);
                    float cosA = cos(h);
                    float sinA = sin(h);
                    return c * cosA + cross(k, c) * sinA + k * dot(k, c) * (1.0 - cosA);
                }
                void main() {
                    float d = length(gl_PointCoord - 0.5);
                    float core = smoothstep(0.15, 0.0, d);
                    float halo = smoothstep(0.5, 0.2, d);
                    float alpha = (core * 0.8) + (halo * 0.2);
                    alpha *= 0.8 + 0.2 * sin(time * 5.0 * vR + vR * 10.0);
                    vec3 color = hueShift(vCol, time * hueSpeed);
                    vec3 finalColor = mix(color, vec3(1.0, 1.0, 1.0), core * 0.6);
                    if (alpha < 0.01) discard;
                    gl_FragColor = vec4(finalColor, alpha);
                }`,
            transparent: true,
            depthWrite: false,
            vertexColors: true,
            blending: THREE.AdditiveBlending
        });
        return new THREE.Points(geo, mat);
    }

    function createSparkles(count) {
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(count * 3);
        const size = new Float32Array(count);
        const rnd = new Float32Array(count * 3);
        for (let i = 0; i < count; i++) {
            size[i] = 0.5 + Math.random() * 0.8;
            rnd[i * 3] = Math.random() * 10;
            rnd[i * 3 + 1] = Math.random() * Math.PI * 2;
            rnd[i * 3 + 2] = 0.5 + 0.5 * Math.random();
        }
        geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        geo.setAttribute('size', new THREE.BufferAttribute(size, 1));
        geo.setAttribute('random', new THREE.BufferAttribute(rnd, 3));
        const mat = new THREE.ShaderMaterial({
            uniforms: { time: { value: 0 } },
            vertexShader: `
                uniform float time;
                attribute float size;
                attribute vec3 random;
                varying float vRnd;
                void main() {
                    vRnd = random.z;
                    vec3 p = position;
                    float t = time * 0.25 * random.z;
                    float ax = t + random.y, ay = t * 0.75 + random.x;
                    float amp = (0.6 + sin(random.x + t * 0.6) * 0.3) * random.z;
                    p.x += sin(ax + p.y * 0.06 + random.x * 0.1) * amp;
                    p.y += cos(ay + p.z * 0.06 + random.y * 0.1) * amp;
                    p.z += sin(ax * 0.85 + p.x * 0.06 + random.z * 0.1) * amp;
                    vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);
                    gl_PointSize = size * (300.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }`,
            fragmentShader: `
                uniform float time;
                varying float vRnd;
                void main() {
                    float flicker = sin((time * 2.5 * vRnd) + vRnd * 6.28);
                    flicker = pow(flicker, 2.0);
                    flicker = smoothstep(0.7, 1.0, flicker);
                    float d = length(gl_PointCoord - vec2(0.5));
                    float alpha = 1.0 - smoothstep(0.4, 0.5, d);
                    alpha *= (0.5 + flicker * 0.5);
                    if (alpha < 0.01) discard;
                    vec3 color = mix(vec3(0.7, 0.8, 1.0), vec3(1.0, 1.0, 1.0), flicker);
                    gl_FragColor = vec4(color, alpha);
                }`,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });
        return new THREE.Points(geo, mat);
    }

    function init() {
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050203, 0.012);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2500);
        camera.position.set(0, 0, 90);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById("container").appendChild(renderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 20;
        controls.maxDistance = 250;
        controls.target.set(0, 0, 0);
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;
        controls.enablePan = false;
        controls.touches = {
            ONE: THREE.TOUCH.ROTATE,
            TWO: THREE.TOUCH.DOLLY_PAN
        };

        const loader = new FontLoader();
        loader.load('https://cdn.jsdelivr.net/npm/three@0.168.0/examples/fonts/helvetiker_regular.typeface.json', function (loadedFont) {
            font = loadedFont;

            stars = createStars();
            scene.add(stars);

            const palette = [0xff61a6, 0xff005e, 0xff9933, 0xffee55, 0xffffff].map(c => new THREE.Color(c));
            particles = makeParticles(PARTICLE_COUNT, palette);
            sparkles = createSparkles(SPARK_COUNT);
            scene.add(particles);
            scene.add(sparkles);

            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.25, 0.4, 0.85));
            const after = new AfterimagePass();
            after.uniforms.damp.value = 0.92;
            composer.addPass(after);
            composer.addPass(new OutputPass());

            setPattern(currentPattern, 0);

            document.getElementById('morphButton').addEventListener('click', () => {
                if (!isTrans) {
                    beginMorph();
                }
            });
            document.getElementById('morphButton').addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (!isTrans) {
                    beginMorph();
                }
            }, { passive: false });

            setTimeout(() => {
                const loadingScreen = document.getElementById('loadingScreen');
                loadingScreen.classList.add('hidden');
                setTimeout(() => loadingScreen.style.display = 'none', 500);
            }, 1000);

            animate();
        }, undefined, () => {
            console.error('Font loading failed');
            const loadingScreen = document.getElementById('loadingScreen');
            loadingScreen.innerHTML = '<span>Failed to load resources. Please refresh.</span>';
        });

        let lastWidth = window.innerWidth, lastHeight = window.innerHeight;
        window.addEventListener("resize", () => {
            if (Math.abs(window.innerWidth - lastWidth) > 10 || Math.abs(window.innerHeight - lastHeight) > 10) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
                lastWidth = window.innerWidth;
                lastHeight = window.innerHeight;
            }
        }, { passive: true });

        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            }, 100);
        }, { passive: true });
    }

    function setPattern(i, time) {
        const pts = PATTERNS[i](PARTICLE_COUNT, time);
        basePositions = pts;
        const particleArr = particles.geometry.attributes.position.array;
        const sparkleArr = sparkles.geometry.attributes.position.array;

        for (let j = 0; j < PARTICLE_COUNT; j++) {
            const idx = j * 3;
            const p = pts[j] || new THREE.Vector3();
            particleArr[idx] = p.x;
            particleArr[idx + 1] = p.y;
            particleArr[idx + 2] = p.z;
            if (j < SPARK_COUNT) {
                sparkleArr[idx] = p.x;
                sparkleArr[idx + 1] = p.y;
                sparkleArr[idx + 2] = p.z;
            }
        }
        particles.geometry.attributes.position.needsUpdate = true;
        sparkles.geometry.attributes.position.needsUpdate = true;
    }

    function beginMorph() {
        isTrans = true;
        prog = 0;
        const next = (currentPattern + 1) % PATTERNS.length;
        const fromPts = particles.geometry.attributes.position.array.slice();
        const toPts = PATTERNS[next](PARTICLE_COUNT, clock.getElapsedTime());

        const to = new Float32Array(PARTICLE_COUNT * 3);
        if (toPts.length > 0) {
            for (let j = 0; j < PARTICLE_COUNT; j++) {
                const idx = j * 3, p = toPts[j] || new THREE.Vector3();
                to[idx] = p.x; to[idx + 1] = p.y; to[idx + 2] = p.z;
            }
            particles.userData = { from: fromPts, to, next };
            sparkles.userData = { from: fromPts, to, next };
        }
    }

    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta(), t = clock.getElapsedTime();

        controls.update();

        if (particles) particles.material.uniforms.time.value = t;
        if (sparkles) sparkles.material.uniforms.time.value = t;

        if (isTrans) {
            prog += morphSpeed;
            const eased = prog >= 1 ? 1 : 1 - Math.pow(1 - prog, 3);
            const { from, to, next } = particles.userData;

            const animatedToPts = PATTERNS[next](PARTICLE_COUNT, t);

            if (to) {
                const particleArr = particles.geometry.attributes.position.array;
                const sparkleArr = sparkles.geometry.attributes.position.array;
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const idx = i * 3;
                    const pTo = animatedToPts[i] || new THREE.Vector3();

                    const pFinalX = from[idx] + (pTo.x - from[idx]) * eased;
                    const pFinalY = from[idx + 1] + (pTo.y - from[idx + 1]) * eased;
                    const pFinalZ = from[idx + 2] + (pTo.z - from[idx + 2]) * eased;

                    particleArr[idx] = pFinalX;
                    particleArr[idx + 1] = pFinalY;
                    particleArr[idx + 2] = pFinalZ;

                    if (i < SPARK_COUNT) {
                        sparkleArr[idx] = pFinalX;
                        sparkleArr[idx + 1] = pFinalY;
                        sparkleArr[idx + 2] = pFinalZ;
                    }
                }
                particles.geometry.attributes.position.needsUpdate = true;
                sparkles.geometry.attributes.position.needsUpdate = true;
            }
            if (prog >= 1) {
                currentPattern = next;
                isTrans = false;
            }
        } else if (particles) {
            setPattern(currentPattern, t);
        }

        if (composer) {
            composer.render(dt);
        }
    }

    init();
    </script>
</body>
</html>
